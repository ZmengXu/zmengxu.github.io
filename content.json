{"meta":{"title":"Zmeng Blogs","subtitle":"记一些IoT和OpenFOAM的事儿","description":null,"author":"Zmeng","url":"http://zmengxu.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-11-01T21:20:52.077Z","updated":"2020-11-01T21:20:52.077Z","comments":false,"path":"/404.html","permalink":"http://zmengxu.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2019-04-09T10:46:12.000Z","updated":"2020-11-01T21:20:52.077Z","comments":false,"path":"about/index.html","permalink":"http://zmengxu.github.io/about/index.html","excerpt":"","text":"Welcome to Zmeng Blog! I am Zmeng, now a Ph.D. student at Lund University in Sweden. My interest lies on Large-eddy simulation (LES) and the internet of thing (IoT). The first one is my work, focusing on the numerical simulation of reacting flow using OpenFOAM. The second one is an avocation, I came to it 10 years ago since I was an undergraduate. This Zmeng Blog is used to record my learning experience on these two aspects: The tools and skills on using OpenFOAM Use and write embedded operating system Subscribe from this blogI am a lazy guy, updating the Blog every now and then. If you would like to be informed when I release new posts, please subscribe it. There are two ways to subscribe this Blog. Chrome Browser subscribeInstall the Chrome Plug-in RSS Feed Reade, and then click this link. Email subscribeClick this link to register your email. The Google FeedBurner will send you email when I have new posts. Contact meThe source code from this Blog are published on GitHub. My user name is ZmengXu, feel free to follow me. Friends Yan Zhang’s Blog OpenFOAM 成长之路 Yan Zhang is my friend. He is an expert on OpenFOAM. His Blog OpenFOAM 成长之路 collects OpenFOAM Learning materials and analyses the libraries, such as Lagrangian thermophysicalModels and combustionModels."},{"title":"categories","date":"2019-04-09T14:58:57.000Z","updated":"2020-11-01T21:20:52.077Z","comments":false,"path":"categories/index.html","permalink":"http://zmengxu.github.io/categories/index.html","excerpt":"","text":""},{"title":"messages","date":"2019-04-18T09:28:11.000Z","updated":"2020-11-01T21:20:52.077Z","comments":true,"path":"messages/index.html","permalink":"http://zmengxu.github.io/messages/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-09T14:59:09.000Z","updated":"2020-11-01T21:20:52.077Z","comments":false,"path":"tags/index.html","permalink":"http://zmengxu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"How does the dynamic library loading work in OpenFOAM","slug":"DynamicLibraries","date":"2020-10-31T22:03:54.000Z","updated":"2020-11-01T21:20:52.077Z","comments":true,"path":"2020/10/DynamicLibraries/","link":"","permalink":"http://zmengxu.github.io/2020/10/DynamicLibraries/","excerpt":"","text":"In OpenFOAM, the solvers and numerical models are separated. Most of the numerical models are located in the $FOAM_SRC path, and being compiled to a dynamic library “.so” binary file, which can be loaded either by linking it during the solver compiling process or loading it by specify the “.so” file in the case controlDict. For example, we develop a new combustion model, named PaSR, and compile it to a “libPaSR.so”. When we run a case, we just need to add a line libs (&quot;libPaSR.so&quot;); in controlDict. Then, we can see and use this model in the reactingFoam solver. How does the “libPaSR.so” file is loaded, and why the solver knows that a new model “PaSR” is available? This blog will explain it. dynamic library loading in C++Before digging into OpenFOAM, let’s see how does the dynamic library is loaded in C++. There are three famous function named dlopen, dlsym and dlclose, which are used to open, find function address and close library, in your operating system. library loading searching and closingI wrote a short code to demonstrate how does it work, see https://github.com/ZmengXu/dynamicLibloading/tree/master/ch01 First, we define two models WSR and PaSR (which are two simple combustion model) in two .C files. Each file has only one simple function, named get_library_name. Compiling these two .C files to two libraries, libWSR.so and libPaSR.so. 12345// In WSR.Cchar* get_library_name(void)&#123; return \"This is WSR\";&#125; 12345// In PaSR.Cchar* get_library_name(void)&#123; return \"This is PaSR\";&#125; Second, we write a solver named solverFoam to call get_library_name function in libWSR.so and libPaSR.so. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dlfcn.h&gt;#include \"word.H\"#include \"IOstreams.H\"using namespace Foam;// define a function pointer typetypedef char* (*funcType)(void);int main(int argc, char *argv[])&#123; if(argc&lt;2) &#123; Info &lt;&lt; \"usage: &lt;library&gt;\\n\" &lt;&lt; endl; return 0; &#125; char* librarypath = argv[1]; // RTLD_LAZY means \"there may be symbols that can't be resolved; // don't try to resolve them until they're used.\" auto libhandle = dlopen(librarypath, RTLD_LAZY); if(libhandle != NULL) &#123; Info &lt;&lt; librarypath &lt;&lt; \" is found.\" &lt;&lt; endl; auto voidPtr = dlsym(libhandle, \"_Z16get_library_namev\"); funcType funcPtr = (funcType)voidPtr; Info &lt;&lt; funcPtr() &lt;&lt; endl; dlclose(libhandle); &#125; else &#123; Info &lt;&lt; librarypath &lt;&lt; \" is not found.\" &lt;&lt; endl; &#125; Info &lt;&lt; \"End.\" &lt;&lt; endl; return 0;&#125; In this code, we get the librarypath from the solver argument, and try to find the dynamic library, load the library to computer memory and get a handle libhandle using dlopen. We use dlsym to find the function _Z16get_library_namev in this library and call this function to print its information. you can use Allrun in https://github.com/ZmengXu/dynamicLibloading/blob/master/Allrun to compile and run it. 1solverFoam \"libWSR.so\" For example, typing the above commands after compiling the library and solver. It will find the “libWSR.so” in $LD_LIBRARY_PATH and printing the following results. 123libWSR.so is found.This is WSREnd. function name decorationHere, we have two things need to be explained: typedef char* (*funcType)(void); is an alias, define a function pointer type. This function has a return value of char* and a void argument. We call this kind of function as funcType. Now you can understand that Line 32: funcType funcPtr = (funcType)voidPtr; means that we are about to convert voidPtr to a function pointer and assign it to a new funcType type function pointer funcPtr. Thus, it can be used as funcPtr() in Line 34. You must be curious that the function name we defined in PaSR.C is “get_library_name”, but why we are looking for the function name “_Z16get_library_namev”. This is due to the name mangling (also called name decoration) in C++ compiler. We can use objdump -tT $FOAM_USER_LIBBIN/libPaSR.so or nm -D $FOAM_USER_LIBBIN/libPaSR.so to see the function list in the libPaSR.so dynamic libray. This is an example for nm -D $FOAM_USER_LIBBIN/libPaSR.so result, you can find _Z16get_library_namev in the optput. 12345678910111213141516170000000000201040 B __bss_start U __cxa_atexit w __cxa_finalize0000000000201040 D _edata0000000000201048 B _end0000000000000924 T _fini w __gmon_start__0000000000000748 T _init w _ITM_deregisterTMCloneTable w _ITM_registerTMCloneTable w _Jv_RegisterClasses0000000000000900 T _Z16get_library_namev U _ZN4Foam13messageStreamcvRNS_8OSstreamEEv U _ZN4Foam4InfoE U _ZN4FoamlsERNS_7OstreamEPKc U _ZNSt8ios_base4InitC1Ev U _ZNSt8ios_base4InitD1Ev The name mangling is a common issue when you want to use Hybrid Programming in OpenFOAM, like “C” and “C++”, or “fortune” and “C++”. You can use the keyword extern C to avoid the compiler converting function name. For example, we can change WSR.C to: 12345678910111213#ifdef __cplusplusextern \"C\"&#123;#endifchar* get_library_name(void)&#123; return \"This is PaSR\";&#125;#ifdef __cplusplus&#125;#endif compile it and use nm -D $FOAM_USER_LIBBIN/libPaSR.so you can get this. The function name is not decorated anymore. 12345678910110000000000201020 B __bss_start w __cxa_finalize0000000000201020 D _edata0000000000201028 B _end0000000000000688 T _fini0000000000000680 T get_library_name w __gmon_start__0000000000000540 T _init w _ITM_deregisterTMCloneTable w _ITM_registerTMCloneTable w _Jv_RegisterClasses dynamic library loading in OpenFOAMIn OpenFOAM, the dynamic library are loaded and unloaded implicitly in the dlLibraryTable class, see $FOAM_SRC/OpenFOAM/db/dynamicLibrary/dlLibraryTable. I created a tutorial code to demonstrate how does it work, see https://github.com/ZmengXu/dynamicLibloading/tree/master/ch02 dlLibraryTable classIn the dlLibraryTable class, it has a constructor using a specific dictionary to look through all the libraries, load the libraries to computer memory and store the library names and pointers to libNames_ and libPtrs_ list. When the dlLibraryTable object is deleted, it will call the deconstructor function to unload these libraries. 123456789101112131415161718192021222324252627282930313233// * * * * * * * * * * * * * * * * Constructors * * * * * * * * * * * * * * //Foam::dlLibraryTable::dlLibraryTable( const dictionary&amp; dict, const word&amp; libsEntry)&#123; open(dict, libsEntry);&#125;// * * * * * * * * * * * * * * * * Destructor * * * * * * * * * * * * * * * //Foam::dlLibraryTable::~dlLibraryTable()&#123; forAllReverse(libPtrs_, i) &#123; if (libPtrs_[i]) &#123; if (debug) &#123; InfoInFunction &lt;&lt; \"Closing \" &lt;&lt; libNames_[i] &lt;&lt; \" with handle \" &lt;&lt; uintptr_t(libPtrs_[i]) &lt;&lt; endl; &#125; if (!dlClose(libPtrs_[i])) &#123; WarningInFunction&lt;&lt; \"Failed closing \" &lt;&lt; libNames_[i] &lt;&lt; \" with handle \" &lt;&lt; uintptr_t(libPtrs_[i]) &lt;&lt; endl; &#125; &#125; &#125;&#125; In the solverFoam, we create a dictionary named controlDict, which will read a dictionary file controlDict, and providing the “libs” as the libsEntry. Then the libraies in the controlDict.libs will be loaded and unloaded automatically. This work is done in the Time class in $FOAM_SRC/OpenFOAM/db/Time and be called from #include &quot;createTime.H&quot; by each CFD solver. This is the reason why the libraries we wrote in the “libs” of controlDict will be loaded automaticlly. The implementation of a short runTime selectionIn terms of the libraries, a base class combustionModelBase and a derived class WSR in the combustionModel folder are compiled to libcombustModel.so file. In the base class, a static HashTable pointer member WordConstructorTablePtr_ is created. A template class addWordConstructorToTable is defined to operate this pointer. In the addWordConstructorToTable constructor, the static HashTable pointer member WordConstructorTablePtr_ is created and insert a “debug value - typeName” pair into the table. Once the constructor is called, it will print “Try to insert typeName” in the constructor, if the typeName exist in the table, it will print “Duplicate entry typeName in runtime selection table”. 123//In combustionModel.Htypedef HashTable&lt; label, word &gt; WordConstructorTable;static WordConstructorTable* WordConstructorTablePtr_; 123456789101112131415161718192021222324template&lt; class Type &gt;class addWordConstructorToTable&#123; public: addWordConstructorToTable( const word&amp; lookup = Type::typeName ) &#123; constructWordConstructorTables(); std::cout &lt;&lt; \"Try to insert \" &lt;&lt; lookup &lt;&lt; \" into the WordConstructorTablePtr_\" &lt;&lt; std::endl; if (!WordConstructorTablePtr_-&gt;insert(lookup, Type::debug)) &#123; std::cerr&lt;&lt; \"Duplicate entry \" &lt;&lt; lookup &lt;&lt; \" in runtime selection table \" &lt;&lt; \"combustionModelBase\" &lt;&lt; std::endl; error::safePrintStack(std::cerr); &#125; &#125; ~addWordConstructorToTable() &#123; destroyWordConstructorTables(); &#125;&#125;; WSR is inherited from the base class, so it also has the template class addWordConstructorToTable, in the WSR.C, an object addWSRWordConstructorTocombustionModelBaseTable_ is defined, which will call the constructor, and get the above output. We will see when the table is created. This is very important. 12//In WSR.CWSR::addWordConstructorToTable&lt; WSR &gt; addWSRWordConstructorTocombustionModelBaseTable_; Apart from that, a static function “New” is defined in combustionModelNew.C to search the typeName from this table. 1234567891011121314151617181920212223242526272829303132333435// static Factory Method (selector)void combustionModelBase::New (const word&amp; modelName)&#123; Info&lt;&lt; \"\\nWe are now in combustionModelBase::New fucntion \" &lt;&lt; \"\\nlooking for the \" &lt;&lt; modelName &lt;&lt; \" in the WordConstructorTable\\n\" &lt;&lt; WordConstructorTablePtr_-&gt;sortedToc() &lt;&lt; endl; // Find the class typeName pointer in the RTS Table // (HashTable&lt;word, autoPtr&lt;combustionModelBase&gt;(*)(word)) WordConstructorTable::iterator cstrIter = WordConstructorTablePtr_-&gt;find(modelName); // If the Factory Method was not found. if (cstrIter == WordConstructorTablePtr_-&gt;end()) &#123; FatalErrorIn ( \"combustionModelBase::New(const word&amp;)\" ) &lt;&lt; \"Unknown combustionModelBase type \" &lt;&lt; modelName &lt;&lt; nl &lt;&lt; nl &lt;&lt; \"Valid combustionModelBase types are :\" &lt;&lt; endl &lt;&lt; WordConstructorTablePtr_-&gt;sortedToc() &lt;&lt; exit(FatalError); &#125; Info&lt;&lt; \"\\nWe found the modelName \" &lt;&lt; modelName &lt;&lt; \"\\nThe debug value for it is \" &lt;&lt; (*WordConstructorTablePtr_)[modelName] &lt;&lt; endl;&#125; The order of the dynamic libraries loadingIn the same way, PaSR is defined, the difference is that it is compiled separately to libPaSR.so file. The libcombustModel.so is written in the solverFoam’s Make/options and linked to the solverFoam during the compiling stage. while the libPaSR.so file is loaded when we run the solverFoam. You can use Allrun in https://github.com/ZmengXu/dynamicLibloading/blob/master/Allrun to compile and run it. Before the libPaSR.so is created, we can not find it in the $LD_LIBRARY_PATH, thus only one model WSR is available in the WordConstructorTable. After libPaSR.so is created, you will see the following outputs. 1234567891011121314151617181920212223242526Try to insert WSR into the WordConstructorTablePtr_Entering main()Loading the librariesTry to insert PaSR into the WordConstructorTablePtr_After the libraries are loadingWe are now in combustionModelBase::New fucntionlooking for the PaSR in the WordConstructorTable2(PaSRWSR)We found the modelName PaSRThe debug value for it is 2End It is interesting that WSR is inserted into the WordConstructorTablePtr_ before entring main() function, PaSR is inserted into the WordConstructorTablePtr_ after the libPaSR.so is loaded. This is because that libcombust.so is loaded before the main() function, while libPaSR.so is loaded during the run time. Once the dynamic library is loaded, the objects addWSRWordConstructorTocombustionModelBaseTable_ and addPaSRWordConstructorTocombustionModelBaseTable_ are constructed automatically in the computer memory as global variables. If we load one library twice, the insert function will reject the inserting. This is why we see the Duplicate entry before the OpenFOAM output header.","categories":[{"name":"software","slug":"software","permalink":"http://zmengxu.github.io/categories/software/"}],"tags":[{"name":"code analysis","slug":"code-analysis","permalink":"http://zmengxu.github.io/tags/code-analysis/"},{"name":"OpenFOAM","slug":"OpenFOAM","permalink":"http://zmengxu.github.io/tags/OpenFOAM/"}]},{"title":"在Linux和Windows下安装OpenFOAM-8和OpenFOAMv2006","slug":"OpenFOAMInstall","date":"2020-08-16T20:10:00.000Z","updated":"2020-11-01T21:20:52.077Z","comments":true,"path":"2020/08/OpenFOAMInstall/","link":"","permalink":"http://zmengxu.github.io/2020/08/OpenFOAMInstall/","excerpt":"","text":"OpenFOAM最近发布了最新的两个版本OpenFOAM-8和OpenFOAMv2006, 这篇博客简单介绍一下这两个版本的区别，然后讲一下如何在Ubuntu和Windows系统下安装这两个版本的OpenFOAM。 OpenFOAM的两个版本OpenFOAM有不少分支，其中最常用的有两个版本: OpenFOAM基金会版和ESI集团版。 OpenFOAM基金会版用数字作版本号，名字像OpenFOAM-6，7，8，一年发布一次，网站是https://www.openfoam.org。 ESI集团版最近几年开始用字母v加年份和月份作版本号，比如OpenFAMv1912， v2006，半年发布一次，一般是在当年的6月和12月。网站是https://www.openfoam.com。 这个是OpenFOAM的分支图，OpenFOAM基金会版和ESI集团版在2016年开始分家了，有兴趣的朋友可以看一下OpenFOAM的发展史。 相比它们的发展史，其实我们更关心的是这两个版本功能上差别大不大。总地来说，两者主体内容差别不大，代码风格和计算效率相近。但是最近的几个版本差别开始变大了，有时候同一套代码在一个上编译没问题但在同期的另一个版本却编译不通。ESI版本更新得更激进一些，会有一些OpenFOAM基金会版没有的求解器和算例。 在Ubuntu上安装OpenFOAMOpenFOAM最初是开发在Linux操作系统上的，在Linux上安装OpenFOAM也更方便一些。以Ubuntu为例，讲一下OpenFOAM的两种安装方式。 apt安装最快最方便，但需要联网，需要sudo权限 开机进入Ubuntu，快捷键Ctrl+Alt+T(或者依次点击 应用， 附件， 终端)启动终端，复制下面四行，按照提示输入密码然后确认安装。 1234sudo sh -c \"wget -O - https://dl.openfoam.org/gpg.key | apt-key add -\"sudo add-apt-repository http://dl.openfoam.org/ubuntusudo apt updatesudo apt install openfoam8 上面四行做的事情分别是添加软件包密钥，添加软件仓库地址，更新软件仓库，下载并安装openfoam-8。OpenFOAM会被安装在/opt目录下，默认paraview也会一并安装。 参考https://openfoam.org/download/8-ubuntu/ 。 编译安装大约需要30分钟到6个小时，可以不联网也不用sudo权限 同样，先开机进入Ubuntu，快捷键Ctrl+Alt+T(或者依次点击 应用， 附件， 终端)启动终端，依次复制粘贴下面的命令。 创建OpenFOAM安装目录，建议装在$HOME/OpenFOAM下 12mkdir $HOME/OpenFOAMcd $HOME/OpenFOAM 下载OpenFOAM和ThirdParty源码放在$HOME/OpenFOAM目录下。有网的话直接在终端输入下面两行下载。 12wget -P $HOME/OpenFOAM https://sourceforge.net/projects/openfoam/files/v2006/OpenFOAM-v2006.tgzwget -P $HOME/OpenFOAM https://sourceforge.net/projects/openfoam/files/v2006/OpenFOAM-v2006.tgz 解压到安装目录 12tar -xzf OpenFOAM-v2006.tgz -C $HOME/OpenFOAM tar -xzf ThirdParty-v2006.tgz -C $HOME/OpenFOAM 索引OpenFOAM安装环境 1source ~/OpenFOAM/OpenFOAM-v2006/etc/bashrc 进入$WM_PROJECT_DIR目录并检查安装环境是否满足要求，ubuntu新系统是满足的，如果不满足则需要补充安装相应的库。 12foamfoamSystemCheck 接下来正式编译OpenFOAM，这个过程比较耗时，大约需要30分钟到6个小时 1./Allwmake -s -l -k -j 这里解释一下./Allwmake后面的几个选项的含义，-l是自动记录log文件， -s是在编译过程中废话少说减少log文件大小，-k是跳过编译错误即使编译出错也继续编译完不要停，-j是并行编译可以减少编译时间，后面可以接数字指定编译核数，默认是用所有的核。 编译完以后我们再执行一遍./Allwmake，这一次去掉-k选项，查看编译过程是否出错（这一步操作非必须，可跳过）。 1./Allwmake -s -l -j 一切正常的话会有输出提示，告诉你编译已经完成，接下来测试OpenFOAM。 复制cavity算例到$FOAM_RUN目录，测试blockMesh网格工具和icoFoam求解器 12345runcp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity/cavity $FOAM_RUNcd cavityblockMeshicoFoam 参考https://www.openfoam.com/download/install-source.php 在Windows安装OpenFOAMWSL安装仅适用于Windows 10系统windows 10 提供了适用于Linux子系统WSL (Windows Subsystem for Linux)，你可以在这上面安装Ubuntu子系统，然后参考上一节在Ubuntu上安装OpenFOAM的方法apt或者编译安装OpenFOAM。 开启WSL参考这个帖子https://zhuanlan.zhihu.com/p/34133795 在微软商店里中搜索Ubuntu，安装最新版(目前是Ubuntu 20.04 LTS)。 装好后快捷Win+R打开系统自带的运行命令，输入bash回车就进入Ubuntu的终端了，接下来参考apt安装。 虚拟机安装如果你是windows 7或者windows XP系统，也可以选择安装VMware虚拟机，具体参考李东岳的教程。他提供了VMware虚拟机文件，里面有Ubuntu系统和编译好的OpenFOAM，比较方便。","categories":[{"name":"OpenFOAM","slug":"OpenFOAM","permalink":"http://zmengxu.github.io/categories/OpenFOAM/"}],"tags":[{"name":"course","slug":"course","permalink":"http://zmengxu.github.io/tags/course/"}]},{"title":"Git 的常用用法","slug":"GitUsage","date":"2020-06-25T19:51:54.000Z","updated":"2020-11-01T21:20:52.077Z","comments":true,"path":"2020/06/GitUsage/","link":"","permalink":"http://zmengxu.github.io/2020/06/GitUsage/","excerpt":"","text":"Git and Github Usage Git Cheat SheetGit DocGit 教程 Git and Github Git is the open source distributed version control system that facilitates GitHub activities on your laptop or desktop. It can be used to install update run uninstall package without sudo rights. It can be used to create different environments for software version management. This is useful in switching different project. Github is a platform for hosting and collaborating on Git repositories. InstallationAnaconda in LinuxSee https://git-scm.com/ An example for the git installation in Linux1234apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-devapt-get install gitgit --version An example for the git installation using conda1conda install -c anaconda git How to use condaCONFIGURE TOOLINGSets the name you want atached to your commit transactions 1git config --global user.name \"[name]\" Sets the email you want atached to your commit transactions 1git config --global user.email \"[email address]\" Enables helpful colorization of command line output 1git config --global color.ui auto CREATE REPOSITORIESDownloads a project and its entire version history from github 1git clone [url] Creates a new floder named [project-name]and init it as a local repository 1git init [project-name] or init the current folder 1git init MAKE CHANGESstage files (in the current folder) into the repository 123git add [file]git add -Agit add . Unstages the file, but preserve its contentsLike un-add one of the file 1git reset [file] Deletes the file from the working directory and stages the deletion–cached is “Removes the file from version control but preserves the file locally” 12git rm [file]git rm --cached [file] Changes the file name and prepares it for commit 1git mv [file-original] [file-renamed] record the staged files permanently in version historyDO COMMITS 1git commit -m \"[descriptive message]\" REDO COMMITSErase mistakes and craf replacement historyUndoes all commits afer [commit], preserving changes locally 1git reset [commit] Discards all history and changes back to the specified commit 1git reset --hard [commit] REVIEW HISTORYBrowse and inspect the evolution of project files List all of the files in the current repositoryA text file named .gitignore suppresses accidental versioning offiles and paths matching the specified paterns 12git ls-filesgit ls-files --other --ignored --exclude-standard Lists all new or modified files to be commited 1git status Shows file differences not yet stagedIt works only when you have add this filebut now you change it without adding againexit the environment. 1git diff If it is staged (git add), you can not seethe difference anymore. But you can use thiscommand to see the file differences between staging and the last file version 1git diff --staged Shows content differences between two branches 1git diff [first-branch]...[second-branch] Lists version history for the current branchList the log in breafLists version history for a file, including renames 123git loggit log --onelinegit log --follow [file] Outputs metadata and content changes of the specified commit 1git show [commit] GROUP CHANGESName a series of commits and combine completed effortsThe master branch is created when you record (commit) the first change Lists all local branches in the current repository 1git branch Jump to another branch, or creates a new branch and jump (if not exist) 12git checkout [branch-name]git branch [branch-name] Combines the specified branch’s history into the current branch 12git merge [branch]git rebase [branch] Deletes the specified branch 1git branch -d [branch-name] SAVE FRAGMENTSShelve and restore incomplete changes Temporarily stores all modified tracked files 1git stash Restores the most recently stashed files 1git stash pop Lists all stashed changesets 1git stash list Discards the most recently stashed changeset 1git stash drop SYNCHRONIZE CHANGESRegister a repository bookmark and exchange version history Downloads all history from the repository bookmark 1git fetch [bookmark] Combines bookmark’s branch into current local branch 1git merge [bookmark]/[branch] Uploads all local branch commits to GitHub 123git push [alias] [branch]git push origin devgit push -u origin [branch] Uploads a specific branch (dev) to GitHub, if there is no dev branch in GitHub, a new branch will be created 1git push origin dev Downloads bookmark history and incorporates changes 1git pull Glossarygit: an open source, distributed version-control systemGitHub: a platform for hosting and collaborating on Git repositoriescommit: a Git object, a snapshot of your entire repository compressed into a SHAbranch: a lightweight movable pointer to a commitclone: a local version of a repository, including all commits and branchesremote: a common repository on GitHub that all team member use to exchange their changesfork: a copy of a repository on GitHub owned by a different userpull request: a place to compare and discuss the differences introduced on a branch with reviews, comments, integrated tests, and moreHEAD: representing your current working directory, the HEAD pointer can be moved to different branches, tags, or commits when using git checkout","categories":[{"name":"software","slug":"software","permalink":"http://zmengxu.github.io/categories/software/"}],"tags":[{"name":"git","slug":"git","permalink":"http://zmengxu.github.io/tags/git/"}]},{"title":"TecentOS tiny in STM32F4","slug":"TecentOS-tiny-in-STM32F4","date":"2020-05-24T17:41:27.000Z","updated":"2020-11-01T21:20:52.077Z","comments":true,"path":"2020/05/TecentOS-tiny-in-STM32F4/","link":"","permalink":"http://zmengxu.github.io/2020/05/TecentOS-tiny-in-STM32F4/","excerpt":"","text":"2019 年腾讯开源了自己的物联网(internet of thing, IoT) 操作系统 TencentOS tiny，我加入了他们的官方讨论群，关注了很久。最近疫情在家把TencentOS tiny移植到了自己的一块STM32F407的开发板上，移植还算顺利，这里记录一下过程。 需求腾讯官方移植指南没有具体型号MCU的介绍，网上我只找到了这篇博客 https://juejin.im/post/5da7289d51882553690284a3 介绍了STM32F103的MCU的移植。我自己的开发板STM32F407的，网上没有，有必要记录下来供参考。 开发板介绍我用的是这个STM32F407VET6 black board开发板，ARM Cortex-M4 内核，相同内核的开发板都可以参考。 STM32F407VET6 black board 具体步骤 创建keil下的裸机工程模板先找到开发板的前后台系统工程模板，一般买开发板的时候学习资料里就有，也可以在我的github上下载，这是下载链接https://github.com/ZmengXu/STM32ProjectTemplate.git。 用Keil软件(也可以在linux或者mac上写个Makefile文件通过arm-none-eabi-gcc来编译，后面我会写个这样的教程)打开工程模板中USER/Template.uvprojx文件, 我用的是Keil μVision5，打开后是这样的 F7编译工程文件，如果下载的是我GitHub上提供的文件，编译是可以直接通过的，并且会自动新建一个OBJ文件夹，并在该文件夹下生成Template.hex的16进制文件。 接下来将Template.hex文件写入STM32F407开发板。我用的是ST-LINK V2 采用SW方式连接开发板，打开魔法棒Options for Target按钮，选Debug， 右侧Use选项打开下拉菜单选ST-Link Debugger，然后点击setting，修改ort选项为SW，连接好开发板插入ST-LINK，这时候右侧SW Device就可以看到电脑找到了刚刚插入的设备。 回到桌面，点击Download，刚刚的16进制文件Template.hex就被写入开发板了。连接上串口，打开串口调试助手，按一下开发板上的复位，调试助手就可以收到这样的输入信息了。 创建新的工程并移植TencentOS tiny下载TencentOS tiny的源码去GitHub上https://github.com/Tencent/TencentOS-tiny或者去腾讯工蜂开源仓https://git.code.tencent.com/Tencent_Open_Source/TencentOS-tiny下载。我是在GitHub上下的，参考杰杰的建议后者会快些。 下载下来后有很多子目录，但我们只需要下面几个目录。 一级目录 二级目录 说明 arch arm/arm-v7m TencentOS tiny适配的IP核架构（含M核中断、调度、tick相关代码） board STM32F407VGT6_discovery/TOS_CONFIG 移植目标芯片的工程文件的配置文件，根据情况选一个最接近自己开发板的 kernel core TencentOS tiny内核源码 pm tiny低功耗模块源码，本次移植暂不使用 osal cmsis_os TencentOS tiny提供的cmsis os 适配 修改工程文件复制一个模板工程目录，重命名为Demo_MultiTask，在该目录下新建一个文件夹，TencentOS，然后把arm-v7m，core和cmsis_os目录复制到TencentOS中。 创建一个TOS_CONFIG子文件夹，并创建一个tos_config.h文件，下面是我用到的，附有腾讯官方解释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#ifndef _TOS_CONFIG_H_#define _TOS_CONFIG_H_#include \"stm32f4xx.h\" // 目标芯片头文件，用户需要根据情况更改#define TOS_CFG_TASK_PRIO_MAX 10u // 配置TencentOS tiny默认支持的最大优先级数量#define TOS_CFG_ROUND_ROBIN_EN 0u // 配置TencentOS tiny的内核是否开启时间片轮转#define TOS_CFG_OBJECT_VERIFY_EN 1u // 配置TencentOS tiny是否校验指针合法#define TOS_CFG_TASK_DYNAMIC_CREATE_EN 1u // TencentOS tiny 动态任务创建功能宏#define TOS_CFG_EVENT_EN 1u // TencentOS tiny 事件模块功能宏#define TOS_CFG_MMBLK_EN 1u //配置TencentOS tiny是否开启内存块管理模块#define TOS_CFG_MMHEAP_EN 1u //配置TencentOS tiny是否开启动态内存模块#define TOS_CFG_MMHEAP_DEFAULT_POOL_EN 1u // TencentOS tiny 默认动态内存池功能宏#define TOS_CFG_MMHEAP_DEFAULT_POOL_SIZE 0x100 // 配置TencentOS tiny默认动态内存池大小#define TOS_CFG_MUTEX_EN 1u // 配置TencentOS tiny是否开启互斥锁模块#define TOS_CFG_MESSAGE_QUEUE_EN 1u // 配置TencentOS tiny是否开启消息队列模块#define TOS_CFG_MAIL_QUEUE_EN 1u // 配置TencentOS tiny是否开启消息邮箱模块#define TOS_CFG_PRIORITY_MESSAGE_QUEUE_EN 1u // 配置TencentOS tiny是否开启优先级消息队列模块#define TOS_CFG_PRIORITY_MAIL_QUEUE_EN 1u // 配置TencentOS tiny是否开启优先级消息邮箱模块#define TOS_CFG_TIMER_EN 1u // 配置TencentOS tiny是否开启软件定时器模块#define TOS_CFG_PWR_MGR_EN 0u // 配置TencentOS tiny是否开启外设电源管理模块#define TOS_CFG_TICKLESS_EN 0u // 配置Tickless 低功耗模块开关#define TOS_CFG_SEM_EN 1u // 配置TencentOS tiny是否开启信号量模块#define TOS_CFG_TASK_STACK_DRAUGHT_DEPTH_DETACT_EN 1u // 配置TencentOS tiny是否开启任务栈深度检测#define TOS_CFG_FAULT_BACKTRACE_EN 0u // 配置TencentOS tiny是否开启异常栈回溯功能#define TOS_CFG_IDLE_TASK_STK_SIZE 1512 // 配置TencentOS tiny空闲任务栈大小#define TOS_CFG_CPU_TICK_PER_SECOND 1000u // 配置TencentOS tiny的tick频率#define TOS_CFG_CPU_CLOCK (SystemCoreClock) // 配置TencentOS tiny CPU频率#define TOS_CFG_TIMER_AS_PROC 1u // 配置是否将TIMER配置成函数模式#endif 添加.c和.s文件到工程中打开USER/Template.uvprojx文件，依次添加arch平台代码和内核源码。具体地 点击File Extensions新建工程分组tos/arch。点击右侧的Add Files添加TencentOS\\arm-v7m\\cortex-m4\\common里的tos_cpu.c文件和TencentOS\\arm-v7m\\cortex-m4\\armcc里的port_c.c和port_c.S。同样新建工程分组和tos/kernel。添加TencentOS\\kernel\\core里的所有.c文件。另外，pm是内核中的低功耗组件，基础移植的时候可以不添加。 添加TencentOS tiny头文件目录打开魔法棒Options for Target按钮，选C/C++， 右侧Use选项打开下拉菜点击添加的头文件目录如下： 12345..\\TencentOS\\arm-v7m\\common\\include..\\TencentOS\\arm-v7m\\cortex-m4\\armcc..\\TencentOS\\core\\include..\\TencentOS\\cmsis_os..\\TencentOS\\TOS-CONFIG //在C/C++界面上一定要勾上c99，否则编译的时候出underfined reference 的错误（好像不是这个原因，是我忘了添加tos_cpu.c文件了，不需要） 修改部分代码修改SYSTEM/USART/usart.c第29行，_sys_exit(int x) 改为 void _sys_exit(int x) 修改stm32f4xx_it.c 包含#include &quot;tos_k.h&quot; 头文件 注释掉PendSV_Handler函数 在SysTick_Handler函数中添加TencentOS tiny的调度处理函数修改后stm32f4xx_it.c长这样123456789101112131415161718192021222324252627#include &quot;stm32f4xx_it.h&quot;#include &quot;tos_k.h&quot;...&#x2F;** * @brief This function handles PendSVC exception. * @param None * @retval None *&#x2F;&#x2F;&#x2F;void PendSV_Handler(void)&#x2F;&#x2F;&#123;&#x2F;&#x2F;&#125;&#x2F;** * @brief This function handles SysTick Handler. * @param None * @retval None *&#x2F;void SysTick_Handler(void)&#123; if (tos_knl_is_running()) &#123; tos_knl_irq_enter(); tos_tick_handler(); tos_knl_irq_leave(); &#125;&#125;... 编写main.c这里参考官方测试代码，原链接在这里 https://github.com/Tencent/TencentOS-tiny/blob/master/doc/10.Porting_Manual_for_KEIL.md 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &quot;sys.h&quot;#include &quot;delay.h&quot;#include &quot;usart.h&quot;#include &quot;tos_k.h&quot;#include &quot;cmsis_os.h&quot;&#x2F;&#x2F;task1#define TASK1_STK_SIZE 256void task1(void *pdata);osThreadDef(task1, osPriorityNormal, 1, TASK1_STK_SIZE);&#x2F;&#x2F;task2#define TASK2_STK_SIZE 256void task2(void *pdata);osThreadDef(task2, osPriorityNormal, 1, TASK2_STK_SIZE);void task1(void *pdata)&#123; int count &#x3D; 1; while(1) &#123; printf(&quot;\\r\\nHello world!\\r\\n###This is task1 ,count is %d \\r\\n&quot;, count++); osDelay(2000); &#125;&#125;void task2(void *pdata)&#123; int count &#x3D; 1; while(1) &#123; printf(&quot;\\r\\nHello TencentOS !\\r\\n***This is task2 ,count is %d \\r\\n&quot;, count++); osDelay(1000); &#125;&#125;int main(void)&#123; uart_init(115200); &#x2F;&#x2F;bps 115200 printf(&quot;Welcome to TencentOS tiny\\r\\n&quot;); osKernelInitialize(); &#x2F;&#x2F;TOS Tiny kernel initialize osThreadCreate(osThread(task1), NULL);&#x2F;&#x2F; Create task1 osThreadCreate(osThread(task2), NULL);&#x2F;&#x2F; Create task2 osKernelStart();&#x2F;&#x2F;Start TOS Tiny&#125; 编译并测试编译和下载与模板例子模板例子一样，F7编译工程文件，没有错误的话连接ST-LINK V2和开发板，点击Download下载程序到开发板。 找一个USB转串口连接上电脑和开发板的UART1端口，记得TX-RX，RX-TX交替连接。打开串口调试助手，选择波特率115200，然后复位开发板，就可以收到上面的信息了。task1和task2交替打印，就说明TencentOS-tiny的任务调度功能实现了，移植成功。 下载链接我放在github上了https://github.com/ZmengXu/STM32ProjectTemplate.git。如果访问不了，可以发邮件找我要。","categories":[{"name":"IoT","slug":"IoT","permalink":"http://zmengxu.github.io/categories/IoT/"},{"name":"STM32","slug":"IoT/STM32","permalink":"http://zmengxu.github.io/categories/IoT/STM32/"}],"tags":[{"name":"TecentOS tiny","slug":"TecentOS-tiny","permalink":"http://zmengxu.github.io/tags/TecentOS-tiny/"}]},{"title":"SpanwiseAverage","slug":"SpanwiseAverage","date":"2019-04-19T18:59:31.000Z","updated":"2020-11-01T21:20:52.077Z","comments":true,"path":"2019/04/SpanwiseAverage/","link":"","permalink":"http://zmengxu.github.io/2019/04/SpanwiseAverage/","excerpt":"","text":"很久之前就把网站搭建好了，但一直没往里写东西。最近被一位神秘的大佬催更，写篇文章吧。无意中看到了一个之前写的后处理工具，决定就拿这个作第一篇博客。 需求OpenFOAM不能对计算结果进行周向平均处理。所以就写了个后处理程序，用于对轴向对称流场的三维结果进行周向平均。 解决思路确定一个周向平均操作需要给定两个量，基点basePoint和旋转向量spanwiseVector。接下来可以通过两种方法实现周向平均过程。 对流场的所有网格遍历，将所有位于同一圆周线上的点加和求平均。可以这么实现：对原始坐标系进行坐标变换，将原来的三维坐标(x,y,z)映射到原点为basePoint高度方向为spanwiseVector的圆柱坐标系（r,z,theta）中；然后在theta方向上求平均，即将所有具有相同（r,z）的节点上的物理量取平均。 取有限个经过基点basePoint和旋转向量spanwiseVector的截面，将各截面上的物理量值求平均。这么实现：过基点和旋转向量选取任意一个截面，提取截面上各点的物理量值；将该初始截面旋转一个角度dTheta，对旋转后的新的截面也提取一次。如此，旋转一周均匀截取n个截面。最终对这n个截面上的物理量值取平均，得到周向平均的结果。 显然，当截面数n比较小的情况下，方案二的计算量显著小于方案一；和理论值之间的偏差取决于截面数量，精度可控。所以接下来就按照方案二的思路来介绍，代码是基础OpenFOAM-4.1写的。 具体步骤 首先需要确定一个初始截面，提取截面上的坐标，在圆柱坐标系中记为（r,z,0）； 将初始截面上的每个点绕基点和旋转向量旋转角度dTheta，得到一个旋转后的采样点的坐标（r,z,theta）； 通过插值的方法得到旋转后的采样点上的物理量值。 重复步骤2-3，依次获取n个采样点的物理量值，取平均得到初始截面上任意一点（r,z,0）的周向平均值。 实现方法上参考了这篇cfd-online帖子。 1. 确定初始截面值得一提的是，周向平均并不是一个普适性的后处理过程，它对计算域的几何形状有要求。有些几何形状并不是轴向对称，或者不是关于用户提供的基点basePoint和旋转向量normVector轴向对称的，从原理上讲本就无法进行周向平均。那么这样的几何形状怎么处理，这里涉及到一个容错的问题，这在后面会提到，这应该也是为什么OpenFOAM官方没有提供周向平均后处理程序的一个原因。 本着尽可能用OpenFOAM现有类和函数的原则，我们找到了cuttingPlane类和sampledSurface类，前者可以根据基点basePoint和法向量normVector截取一个初始截面并获得在该截面上的点的坐标，后者则是用来获取这些点的物理量值的。显然，我们直接继承这两个类就可以完成步骤1的主要内容了，而OpenFOAM恰好有一个很好的例子，就是sampledPlan类，同时继承了上面提到的两个类，它在这里 1$FOAM_SRC&#x2F;sampling&#x2F;sampledSurface&#x2F;sampledPlan 所以我们就按照sampledPlan类改写，新建一个新的类sampledPlaneSpanwise，这里截取一段类的声明，新增了采样点个数nPoints_和旋转向量spanwiseVector_. 基点basePoint和初始截面的法向量normVector就不需要了，因为他们可以直接从cuttingPlane类继承来。 sampledPlaneSpanwise/sampledPlaneSpanwise.H 1234567891011121314class sampledPlaneSpanwise: public sampledSurface, public cuttingPlane&#123; &#x2F;&#x2F; Private data &#x2F;&#x2F;- Direction normal to the plane word axis_; &#x2F;&#x2F;- Number of points used to compute the average label nPoints_; &#x2F;&#x2F;- Number of points used to compute the average vector spanwiseVector_; 在sampledPlaneSpanwise类的构造函数中，有这么一段，用于判断初始截面的法向量normVector和旋转向量spanwiseVector是否垂直，这是容错机制的一部分。 sampledPlaneSpanwise/sampledPlaneSpanwise.C 12345678910const vector&amp; normal &#x3D; spanwiseVector_;const vector&amp; planNorm &#x3D; this-&gt;normal();if ( mag(normal&amp;planNorm) &gt; SMALL)&#123; FatalErrorIn ( &quot;Foam::sampledAveragePlane::sampledAveragePlane&quot; ) &lt;&lt; &quot;The spanwiseVector normal is not perpendicular to the plane normal&quot; &lt;&lt; exit(FatalError);&#125; 2. 旋转采样圆周采样类circleSet，可以给定圆心，半径和旋转轴在圆周方向上均匀采样，得到一组采样点的坐标。这么一来，圆柱坐标变换和旋转坐标变换的步骤也省了，所以说还是用OpenFOAM现有类和函数好啊。 circleSet类的声明和定义在这里： 1$FOAM_SRC&#x2F;sampling&#x2F;sampledSet&#x2F;circle 所以，旋转采样就可以这么实现：为每个初始截面上的点currentPoint，创建一个circleSet对象，其中包含nPoints_个采样点，相邻两个采样点之间的夹角是dTheta。 sampledPlaneSpanwise/sampledPlaneSpanwiseTemplates.C 12&#x2F;&#x2F; Extract the circle in the homogeneous direction circleSet line(&quot;circleLine&quot;, mesh(), searchEngine, axis_, circleOrigin, normalVector, currentPoint, dTheta); circleSet在创建新对象时会调用findCell函数查找改采样点是否在计算域内，不在的话会有输出警告。这也是前面提到的容错机制的一种，只有选取了合适的基点basePoint法向量normVector和旋转向量spanwiseVector才能保证所有的采样点都在计算域内。 3. 插值获取采样点上的物理量参考 $FOAM_SRC/sampling/sampledSurface/sampledPlan/sampledPlanTemplates.C 当中的实现方法，调用interpolate函数，就可以得到圆周采样点上的物理量值。实现如下 sampledPlaneSpanwise/sampledPlaneSpanwiseTemplates.C 123456789forAll(line, lineI)&#123; linevalues[lineI] &#x3D; interpolator.interpolate ( line[lineI], line.cells()[lineI], line.faces()[lineI] );&#125; 2. 取周向平均得到圆周采样点上的物理量值后，对nPoints_个点求平均即可得到改点处的周向平均值。对初始截面上每个点在每个物理量场(p, U, T …)上作相同地采样和平均处理，即可得到初始截面上的所有点的周向平均值，输出即可。而输出的格式因为继承了sampling类，既可以导出vtk格式又可以得到行列式的raw格式。具体参考sampledPlan的使用方法一样。文末提供的下载链接中也提供了一个算例作参考。 下载链接我放在github上了https://github.com/ZmengXu/sampledAveragePlane。如果访问不了，可以发邮件找我要。","categories":[{"name":"OpenFOAM","slug":"OpenFOAM","permalink":"http://zmengxu.github.io/categories/OpenFOAM/"},{"name":"utility","slug":"OpenFOAM/utility","permalink":"http://zmengxu.github.io/categories/OpenFOAM/utility/"}],"tags":[{"name":"postProcess","slug":"postProcess","permalink":"http://zmengxu.github.io/tags/postProcess/"}]}],"categories":[{"name":"software","slug":"software","permalink":"http://zmengxu.github.io/categories/software/"},{"name":"OpenFOAM","slug":"OpenFOAM","permalink":"http://zmengxu.github.io/categories/OpenFOAM/"},{"name":"IoT","slug":"IoT","permalink":"http://zmengxu.github.io/categories/IoT/"},{"name":"STM32","slug":"IoT/STM32","permalink":"http://zmengxu.github.io/categories/IoT/STM32/"},{"name":"utility","slug":"OpenFOAM/utility","permalink":"http://zmengxu.github.io/categories/OpenFOAM/utility/"}],"tags":[{"name":"code analysis","slug":"code-analysis","permalink":"http://zmengxu.github.io/tags/code-analysis/"},{"name":"OpenFOAM","slug":"OpenFOAM","permalink":"http://zmengxu.github.io/tags/OpenFOAM/"},{"name":"course","slug":"course","permalink":"http://zmengxu.github.io/tags/course/"},{"name":"git","slug":"git","permalink":"http://zmengxu.github.io/tags/git/"},{"name":"TecentOS tiny","slug":"TecentOS-tiny","permalink":"http://zmengxu.github.io/tags/TecentOS-tiny/"},{"name":"postProcess","slug":"postProcess","permalink":"http://zmengxu.github.io/tags/postProcess/"}]}